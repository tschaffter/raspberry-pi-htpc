---
title: "Performance of Bluetooth gamepads"
author: "Thomas Schaffter, thomas.schaffter@sagebionetworks.org"
date: "`r format(Sys.Date(), '%B %d, %Y')`"
output: 
  html_notebook:
    code_folding: hide
---

```{r}
rm(list=ls())

library(ggplot2)
library(dplyr)
# library(purrr)
# library(tibble)
library(tidyr)
# library(xml2)
```

# Overview

- remove jstest rows with type 129 and 130

Here are the questions that we want to answer:

- Use Built-in Bluetooth or ASUS USB-BT400 USB Adapter
- Use USB 2.0 or 3.0 port for ASUS USB-BT400 USB Adapter
- Use Xbox One S Controller or PS4 Controller
- Does jstest captures all the Bluetooth packages received from the controller?

# Manual preparation of the data

## jstest files

These lines are manually removed from the jstest dump files (`*_jstest.txt`).

- First 4 lines (general info)
- Following lines with event type 129 and 130 (list of all buttons)

## hcidump files

`hcidump` generates several lines for each package received. For each package,
we only keep the line that includes the keyword "ACL data". For example,

```
grep "ACL data" hci0_xbox_front_hcidump.txt > hci0_xbox_front_hcidump_.txt
```

# Data

We define all the parameters of the experiments.

```{r}
hcis <- list(
  hci0 = list(
    name = "Pi4 Bluetooth",
    mac = "DC:A6:32:8A:DA:FD",
    bt_version = "5"
  )
  # hci1 = list(
  #   name = "ASUS USB-BT400",
  #   mac = "5C:F3:70:94:05:7A",
  #   bt_version = "4"
  # )
)

devices <- list(
  xbox = list(
    name = "Xbox One S Controller",
    bt_version = "4.2",
    color = "#107C10"  # Xbox green
  ),
  ps4 = list(
    name = "PS4 Controller",
    bt_version = "4",
    color = "#003791"  # PS dark blue
  )
)

locations <- list(
  front = list(
    name = "Front",
    description = "In front of the TV stand"
  )
  # back = list(
  #   name = "Back",
  #   description = "Behind the TV stand"
  # )
)

data_dir <- "/data"
slate_gray <- "#3A3A3A"
t_max <- 300
```

Helper functions

```{r}
# Reads Bluetooth data generated by my Bash script.
read_bt_data <- function(filename) {
  read.table(file = filename, sep = '\t', header = TRUE)
}

# Reads jstest files.
# Note: Here we use our own timestamp generated with `ts '%s'`. The timestamp
#       generated internally by `jstest` is the number of ms elapsed since the
#       start of the system.
read_jstest_data <- function(filename) {
  df <- read.table(text = gsub(",", "", readLines(filename)))
  data.frame(
    time = df$V1,
    event_type = df$V4,
    event_number = df$V8,
    event_value = df$V10
  )
}

# Reads hcidump data.
read_hcidump_data <- function(filename) {
  df <- read.table(file = filename, sep = ' ', header = FALSE)
  data.frame(
    time = df$V1
  )
}
```

We read the data and apply the following transformation to them for each
experiment.

- Set time to 0 when the first controller button is pressed
- Keep only data between 0 and 300 seconds
- Start HCI RX and TX bytes at 0 bytes (bt data)

```{r}
# generate all the combinations of parameters
experiments <- expand.grid(
  hci = names(hcis), 
  device = names(devices), 
  location = names(locations)
)

# create experiment names 
experiment_names <- experiments %>% 
  unite(x, names(experiments), sep = "_", remove = TRUE) %>% 
  pull(x)

# read and transform data
data <- lapply(1:nrow(experiments), function(i) {
  e <- experiments[i,]

  # read raw data
  bt = read_bt_data(file.path(data_dir, paste(
    e$hci, e$device , e$location, "bt.tsv", sep = "_"
  )))
  js = read_jstest_data(file.path(
    data_dir,
    paste(e$hci, e$device , e$location, "jstest.txt", sep = "_")
  ))
  hcidump = read_hcidump_data(file.path(
    data_dir,
    paste(e$hci, e$device , e$location, "hcidump_.txt", sep = "_")
  ))
  
  # set time to 0 when pressed first controller button
  t0 <- js$time[1]
  bt$time <- bt$time - t0
  js$time <- js$time - t0
  hcidump$time <- hcidump$time - t0
  
  # keep bt data collected after pressing the first button until the end of the
  # experiment defined by t_max
  bt <- subset(bt, time >= 0 & time <= t_max)
  js <- subset(js, time >= 0 & time <= t_max)
  hcidump <- subset(hcidump, time >= 0 & time <= t_max, drop = FALSE)
  
  # start HCI RX and TX bytes at 0 bytes
  bt$hci.rx.bytes <- bt$hci.rx.bytes - bt$hci.rx.bytes[1]
  bt$hci.tx.bytes <- bt$hci.tx.bytes - bt$hci.tx.bytes[1]
  
  list(bt = bt, js = js, hcidump = hcidump)
})

# name data
names(data) <- experiment_names
```

We create a second representation of the data after applying the following
transformations:

- bt data: keep only numeric and variables that may change over time
- js data: count the number inputs per second
- hcidump data: count the number of packets received per second

We then pivot and combine these data to make it easier to plot them.

```{r}
data_ <- lapply(1:nrow(experiments), function(i) {
  e <- experiments[i,]
  name <- paste(e$hci, e$device, e$location, sep = "_")
  d <- data[[name]]
  
  # transform, pivot and combine data
  df <- bind_rows(
    d$bt %>%
      select_if(is.numeric) %>%
      select(-c("hci.bluetooth.version", "dev.0.bluetooth.version")) %>%
      pivot_longer(!time, names_to = "name", values_to = "value"),
  
    d$js %>%
      group_by(time) %>%
      summarise(n_inputs = length(time), .groups = 'drop') %>%
      pivot_longer(!time, names_to = "name", values_to = "value"),
    
    d$hcidump %>%
      group_by(time) %>%
      summarise(n_packets = length(time), .groups = 'drop') %>%
      pivot_longer(!time, names_to = "name", values_to = "value")
  )
  
  # append experiment parameters
  df$hci <- e$hci
  df$device <- e$device
  df$location <- e$location

  df
})
```

# Analysis



```{r, echo=FALSE, message=FALSE, results='hide'}
bt_property <- "hci.rx.bytes"

plots <- lapply(names(data), function(data_name) {
  d <- data[[data_name]]
  p <- ggplot(d$bt, aes_string("time", bt_property)) +
    geom_line()
})

plots
```





Number of inputs per second.

```{r}
js_inputs <- js %>%
  mutate(time_s = as.integer(time/1000)) %>%
  group_by(time_s) %>%
  summarise(n_inputs = length(time_s), .groups = 'drop')

ggplot(js_inputs, aes(time_s, n_inputs)) +
  geom_point(colour = slate_gray, size = 1) +
  stat_smooth(method = loess, formula = 'y ~ x', se = FALSE, data=subset(js_inputs, time_s <= 60)) +
  stat_smooth(method = loess, formula = 'y ~ x', se = FALSE, data=subset(js_inputs, time_s > 120 & time_s <= 180)) +
  stat_smooth(method = loess, formula = 'y ~ x', se = FALSE, data=subset(js_inputs, time_s > 240 & time_s <= 300)) +
  xlab("Time (s)") +
  ylab("Controller inputs")
```







```{r}
ggplot(bt, aes(time, dev.0.lq)) +
  geom_line()
ggplot(bt, aes(time, dev.0.rssi)) +
  geom_line()
ggplot(bt, aes(time, dev.0.tpl)) +
  geom_line()
```


```{r}
ggplot(bt, aes(time, hci.rx.bytes)) +
  geom_line()
ggplot(bt, aes(time, hci.rx.errors)) +
  geom_line()
ggplot(bt, aes(time, hci.rx.acl)) +
  geom_line()
ggplot(bt, aes(time, hci.rx.events)) +
  geom_line()
ggplot(bt, aes(time, hci.rx.sco)) +
  geom_line()
```
```{r}
ggplot(bt, aes(time, hci.tx.bytes)) +
  geom_line()
ggplot(bt, aes(time, hci.tx.errors)) +
  geom_line()
ggplot(bt, aes(time, hci.tx.acl)) +
  geom_line()
ggplot(bt, aes(time, hci.tx.commands)) +
  geom_line()
ggplot(bt, aes(time, hci.tx.sco)) +
  geom_line()
```






```{r}
bt
```

