---
title: "Performance of Bluetooth gamepads"
author: "Thomas Schaffter, thomas.schaffter@sagebionetworks.org"
date: "`r format(Sys.Date(), '%B %d, %Y')`"
output: 
  html_notebook:
    code_folding: hide
---

```{r}
rm(list=ls())

library(ggplot2)
library(dplyr)
# library(purrr)
# library(tibble)
library(tidyr)
# library(xml2)
```

# Overview

- remove jstest rows with type 129 and 130

Here are the questions that we want to answer:

- Use Built-in Bluetooth or ASUS USB-BT400 USB Adapter
- Use USB 2.0 or 3.0 port for ASUS USB-BT400 USB Adapter
- Use Xbox One S Controller or PS4 Controller
- Does jstest captures all the Bluetooth packages received from the controller?

# Manual preparation of the data

## jstest files

These lines are manually removed from the jstest dump files (`*_jstest.txt`).

- First 4 lines (general info)
- Following lines with event type 129 and 130 (list of all buttons)

## hcidump files

`hcidump` generates several lines for each package received. For each package,
we only keep the line that includes the keyword "ACL data". For example,

```
grep "ACL data" hci0_xbox_front_hcidump.txt > hci0_xbox_front_hcidump_.txt
```

# Data

We define all the parameters of the experiments.

```{r}
hcis <- list(
  hci0 = list(
    name = "Pi4 Bluetooth",
    mac = "DC:A6:32:8A:DA:FD",
    bt_version = "5"
  )
  # hci1 = list(
  #   name = "ASUS USB-BT400",
  #   mac = "5C:F3:70:94:05:7A",
  #   bt_version = "4"
  # )
)

devices <- list(
  xbox = list(
    name = "Xbox One S Controller",
    bt_version = "4.2",
    color = "#107C10"  # Xbox green
  ),
  ps4 = list(
    name = "PS4 Controller",
    bt_version = "4",
    color = "#003791"  # PS dark blue
  )
)

locations <- list(
  front = list(
    name = "Front",
    description = "In front of the TV stand"
  )
  # back = list(
  #   name = "Back",
  #   description = "Behind the TV stand"
  # )
)

data_dir <- "/data"
slate_gray <- "#3A3A3A"
t_max <- 300
```

Helper functions

```{r}
# Reads Bluetooth data generated by my Bash script.
read_bt_data <- function(filename) {
  read.table(file = filename, sep = '\t', header = TRUE)
}

# Reads jstest files.
# Note: Here we use our own timestamp generated with `ts '%s'`. The timestamp
#       generated internally by `jstest` is the number of ms elapsed since the
#       start of the system.
read_jstest_data <- function(filename) {
  df <- read.table(text = gsub(",", "", readLines(filename)))
  data.frame(
    time = df$V1,
    event_type = df$V4,
    event_number = df$V8,
    event_value = df$V10
  )
}

# Reads hcidump data.
read_hcidump_data <- function(filename) {
  df <- read.table(file = filename, sep = ' ', header = FALSE)
  data.frame(
    time = df$V1
  )
}
```

Read data

```{r}
# Generates all the combinations of parameters
experiments <- expand.grid(
  hci = names(hcis), 
  device = names(devices), 
  location = names(locations)
)

# Read data
data <- lapply(1:nrow(experiments), function(i) {
  e <- experiments[i,]
  list(
    bt = read_bt_data(file.path(data_dir, paste(e$hci, e$device , e$location, "bt.tsv", sep = "_"))),
    js = read_jstest_data(file.path(data_dir, paste(e$hci, e$device , e$location, "jstest.txt", sep = "_"))),
    hcidump = read_hcidump_data(file.path(data_dir, paste(e$hci, e$device , e$location, "hcidump_.txt", sep = "_")))
  )
})

# Set experiment names
names(data) <- experiments %>% 
  unite(x, names(experiments), sep = "_", remove = TRUE) %>% 
  pull(x)
```

We apply the following transformation to the data of each experiment.

- Set time to 0 when the first controller button is pressed
- Keep only data between 0 and 300 s
- Start HCI RX and TX bytes at 0 bytes (bt data)

```{r}
data_ <- lapply(names(data), function(data_name) {
  d <- data[[data_name]]
  
  # Set time to 0 when pressed first controller button
  t0 <- d$js$time[1]
  d$bt$time <- d$bt$time - t0
  d$js$time <- d$js$time - t0
  
  # Keep bt data collected
  # - after pressing first button
  # - until pressing the last button
  d$bt <- d$bt[d$bt$time >= 0 & d$bt$time <= t_max,]
  d$js <- d$js[d$js$time >= 0 & d$js$time <= t_max,]
  d$hcidump <- d$hcidump[d$hcidump$time >= 0 & d$hcidump$time <= t_max,]

  # Start HCI RX and TX bytes at 0 bytes.
  d$bt$hci.rx.bytes <- d$bt$hci.rx.bytes - d$bt$hci.rx.bytes[1]
  d$bt$hci.tx.bytes <- d$bt$hci.tx.bytes - d$bt$hci.tx.bytes[1]

  d
})
names(data_) <- names(data)
```

Combine all the data

```{r}
data_name <- names(data_)
data_name
data_ <- lapply(data_name, function(data_name) {
  data_name <- "hci0_xbox_front"
  d <- data[[data_name]]

  d$bt %>%
    select_if(is.numeric) %>%
    select(-c("hci.bluetooth.version", "dev.0.bluetooth.version")) %>%
    pivot_longer(!time, names_to = "name", values_to = "value")

  
    
  d$js %>%
    pivot_longer(!time, names_to = "name", values_to = "value")
  
})
names(data_) <- data_name
```



# Analysis



```{r, echo=FALSE, message=FALSE, results='hide'}
bt_property <- "hci.rx.bytes"

plots <- lapply(names(data), function(data_name) {
  d <- data[[data_name]]
  p <- ggplot(d$bt, aes_string("time", bt_property)) +
    geom_line()
})

plots
```





Number of inputs per second.

```{r}
js_inputs <- js %>%
  mutate(time_s = as.integer(time/1000)) %>%
  group_by(time_s) %>%
  summarise(n_inputs = length(time_s), .groups = 'drop')

ggplot(js_inputs, aes(time_s, n_inputs)) +
  geom_point(colour = slate_gray, size = 1) +
  stat_smooth(method = loess, formula = 'y ~ x', se = FALSE, data=subset(js_inputs, time_s <= 60)) +
  stat_smooth(method = loess, formula = 'y ~ x', se = FALSE, data=subset(js_inputs, time_s > 120 & time_s <= 180)) +
  stat_smooth(method = loess, formula = 'y ~ x', se = FALSE, data=subset(js_inputs, time_s > 240 & time_s <= 300)) +
  xlab("Time (s)") +
  ylab("Controller inputs")
```







```{r}
ggplot(bt, aes(time, dev.0.lq)) +
  geom_line()
ggplot(bt, aes(time, dev.0.rssi)) +
  geom_line()
ggplot(bt, aes(time, dev.0.tpl)) +
  geom_line()
```


```{r}
ggplot(bt, aes(time, hci.rx.bytes)) +
  geom_line()
ggplot(bt, aes(time, hci.rx.errors)) +
  geom_line()
ggplot(bt, aes(time, hci.rx.acl)) +
  geom_line()
ggplot(bt, aes(time, hci.rx.events)) +
  geom_line()
ggplot(bt, aes(time, hci.rx.sco)) +
  geom_line()
```
```{r}
ggplot(bt, aes(time, hci.tx.bytes)) +
  geom_line()
ggplot(bt, aes(time, hci.tx.errors)) +
  geom_line()
ggplot(bt, aes(time, hci.tx.acl)) +
  geom_line()
ggplot(bt, aes(time, hci.tx.commands)) +
  geom_line()
ggplot(bt, aes(time, hci.tx.sco)) +
  geom_line()
```






```{r}
bt
```

